<#
.SYNOPSIS
Collects information from all physical and virtual machines in a rack of servers.

.DESCRIPTION
This script will save a XML file containing installed patches/updates, firmware/driver versions, and various software versions.
It is intended to be used for validation of a small set of values and not a global inventory report.
The P&U tool creates inventory reports that can be used for broader coverage.

.PARAMETER RackName
The XML file created will be based on this name.
This parameter is only intended to help the user quickly identify what rack this report is for.

.PARAMETER Nodes
Allows the user to give a specific list of Computer Names to be included in the report.

.PARAMETER NodeTypesAllows the user to target a specific "Type" of system.By default all types will be included.
.PARAMETER RackNumberIf the RackFactory naming standards are followed the script will attempt to discover the cluster names based on this RackNumber value.If non-standard names are used the individual cluster names will need to be supplied by the user.
.PARAMETER MSUClusterSpecify the name of the Management Cluster.This only needs to be supplied if the script is unable to determine this value automatically.
.PARAMETER SSUClusterSpecify the name of the Storage Cluster(s).This only needs to be supplied if the script is unable to determine this value automatically.
.PARAMETER CSUClusterSpecify the name of the Compute Cluster(s).This only needs to be supplied if the script is unable to determine this value automatically.
.PARAMETER ESUClusterSpecify the name of the Edge Cluster(s).This only needs to be supplied if the script is unable to determine this value automatically.
.PARAMETER NoVMMUse this when VMM is not present in the stamp to avoid any queries to the VMM Server.
.PARAMETER UseVMMUse this to force the script to use the VMM Powershell cmdlets to generate the list of servers.By default the Failover Cluster and Hyper-V cmdlets are used.The VMM method is slower and is unable to filter based on rack number.For example, this would mean that every CSU node (regardless of rack number) would be included if the CSU Type was specified.
.PARAMETER SkipNodesA list of Computer Names that should NOT be included.The "LOCALHOST" name will always be added to this list to avoid the Virtual F5 machines.
.PARAMETER UseSECLISetting this to false will force the script to use the Get-PhysicalDisk and Get-StorageEnclosure cmdlets for JBOD information.By default the Dell secli.exe utility will be used to get JBOD disk information.
.PARAMETER SkipDisksSpecifying this will make the script skip the JBOD/Disk inventory.
.EXAMPLE.\Get-InventoryReport.ps1 -RackName D25CL7R01The script would assume this is Rack 1 and attempt to discover all of the machine names based on RackFactory naming standards.
.EXAMPLE.\Get-InventoryReport.ps1 -RackName D25CL7R01 -RackNumber 2The script would attempt to discover all of the machine names based on RackFactory naming standards for Rack 2 of a multi-rack stamp.
.EXAMPLE.\Get-InventoryReport.ps1 -RackName DRRS12R18 -MSUCluster MY-MSU -CSUCluster MY-CSU -SSUCluster MY-SSU -ESUCluster MY-ESUThe script would use the non-standard cluster names as specified to discover the machine names to be included in the report.
.EXAMPLE.\Get-InventoryReport.ps1 -RackName SOMECPS01 -UseVMMThe script would use the VMM server to discover the machine names to be included in the report.
#>[CmdletBinding(DefaultParametersetName="Manual")]Param(    [Parameter(ParameterSetName="UseVMM")]    [Parameter(ParameterSetName="Manual")]    [Parameter(Position=0,Mandatory=$true)][string]$RackName,    [Parameter(ParameterSetName="Manual")]    [Parameter(Mandatory=$false)][string[]]$Nodes,    [Parameter(ParameterSetName="UseVMM")]    [Parameter(ParameterSetName="Manual")]    [ValidateSet("MSU","CSU","ESU","SSU","VM")]    [Parameter(Mandatory=$false)][string[]]$NodeTypes=@("MSU","CSU","ESU","SSU","VM"),    [Parameter(ParameterSetName="Manual")]    [Parameter(Mandatory=$false)][int]$RackNumber=1,    [Parameter(ParameterSetName="Manual")]    [Parameter(Mandatory=$false)][string]$MSUCluster,    [Parameter(ParameterSetName="Manual")]    [Parameter(Mandatory=$false)][string]$SSUCluster,    [Parameter(ParameterSetName="Manual")]    [Parameter(Mandatory=$false)][string]$CSUCluster,    [Parameter(ParameterSetName="Manual")]    [Parameter(Mandatory=$false)][string]$ESUCluster,    [Parameter(ParameterSetName="Manual")]    [Parameter()][switch]$NoVMM,    [Parameter(ParameterSetName="UseVMM")]    [Parameter()][switch]$UseVMM,    [Parameter(ParameterSetName="Manual")]    [Parameter(ParameterSetName="UseVMM")]    [Parameter(Mandatory=$false)][string]$VMMServer,    [Parameter(ParameterSetName="UseVMM")]    [Parameter(ParameterSetName="Manual")]    [Parameter(Mandatory=$false)][string[]]$SkipNodes,    [Parameter(ParameterSetName="Manual")]    [Parameter(ParameterSetName="UseVMM")]    [Parameter(Mandatory=$false)][string]$SupportFileSrc="\\10.197.169.15\Public\CPS\RackFactoryKit_TFS\SIToolkit\Hacks\Inventory\SupportFiles",    [Parameter(ParameterSetName="Manual")]    [Parameter(ParameterSetName="UseVMM")]    [Parameter(Mandatory=$false)][string]$SupportFileUsername="eec",    [Parameter(ParameterSetName="Manual")]    [Parameter(ParameterSetName="UseVMM")]    [Parameter(Mandatory=$false)][string]$SupportFilePassword="P@ssw0rd",    [Parameter(ParameterSetName="UseVMM")]    [Parameter(ParameterSetName="Manual")]    [Parameter()][bool]$UseSECLI=$true,    [Parameter(ParameterSetName="UseVMM")]    [Parameter(ParameterSetName="Manual")]    [Parameter()][switch]$SkipDisks)$StartTime = Get-Date[string]$timestamp = Get-Date -format yyyyMMdd-HHmm[string]$xmlDate = Get-Date -format yyyy-MM-dd[string]$xmlTime = Get-Date -format HH:mm[string]$ScriptPath = (Split-Path $MyInvocation.MyCommand.Path)[string]$RackName = $RackName.Replace(" ","-")[string]$xmlFile = $ScriptPath + "\CPS_" + $RackName + "_Inventory_" + $timestamp + ".xml"[string]$SupportFilePath = $ScriptPath + "\SupportFiles"$MSUNodes=@()$CSUNodes=@()$ESUNodes=@()$SSUNodes=@()$VMList=@()
If ((($Env:COMPUTERNAME).Length -gt 7) -and (($Env:COMPUTERNAME).Split("-").Count -gt 1)){    If(-not(Test-Path "C:\CloudDeployment"))       {        $CpsPrefix = ($Env:COMPUTERNAME).SubString(0, $Env:COMPUTERNAME.IndexOf('-'))    }}If (-not $CpsPrefix){    Throw "Unable to determine CpsPrefix from ComputerName. Please run this script from a Console VM."}$AlwaysSkip = @("LOCALHOST","AFM",($CpsPrefix+"-SSQL-DONE"),"GWTestVM")If (-not $SkipNodes) { $SkipNodes = $AlwaysSkip }Else { $SkipNodes += $AlwaysSkip }$SkipDPMAgent = $false
Function Validate-IPv4{    Param ([string]$ipAddress)    $fourOctets = (($ipAddress.Split(".") | Measure-Object).Count -eq 4)    $checkAddress = [System.Net.IPAddress]::TryParse($ipAddress,[ref] $null)    If ($checkAddress -and $fourOctets){ Return $true }    Else { Return $false}}
If (-not(Test-Path $SupportFilePath -ea SilentlyContinue)){    net use $SupportFileSrc "/u:$SupportFileUsername" $SupportFilePassword | Out-Null    If (Test-Path $SupportFileSrc -ea SilentlyContinue)    {        Robocopy $SupportFileSrc $SupportFilePath *.* /s /e /v | Out-Null    }    Else    {        Throw "ERROR: Unable to contact $SupportFileSrc"     }    If (-not(Test-Path $SupportFilePath -ea SilentlyContinue))    {        Throw "ERROR: Unable to copy $SupportFileSrc to $SupportFilePath"     }}If (!$VMMServer -and !$NoVMM){    # Try to determine the VMM cluster name by finding the prefix    If ($CpsPrefix)    {        $VMMServer =  $CpsPrefix + "-HA-VMM"         If (-not (Test-Connection $VMMServer -Quiet)) { $VMMServer = $Null }    }    If (!$VMMServer)    {        Write-Host "`nNOTE: To skip the VMM version check, use the -NoVMM parameter`n" -ForegroundColor Yellow        If (!$VMMServer)        {            $VMMServer = Read-Host "REQUIRED: Please supply the VMM server name"        }        If (-not(Test-Connection $VMMServer -Quiet))        {            Throw "ERROR: Unable to ping to $VMMServer"        }    }}If ($Nodes){    [string[]]$NodeTypes = @("MANUAL")    $SkipDPMAgent = $true}Else{    # Populate the lists of Nodes    Write-Host "`n`nGETTING LIST OF NODES...`n" -ForegroundColor Yellow    # Make sure FailoverClusters Powershell Module is available    If (-not (Get-Command Get-Cluster -ea SilentlyContinue))    {        If (Get-Module -ListAvailable | Select-String "FailoverClusters") { Import-Module FailoverClusters -Force -ea SilentlyContinue }        Else { Install-WindowsFeature RSAT-Clustering -IncludeAllSubFeature }    }    If (-not (Get-Command Get-Cluster -ea SilentlyContinue)) { Throw "ERROR: Unable to load FailoverClusters Powershell module" }    If ($UseVMM)    {        # Make sure VirtualMachineManager Powershell Module is available        If (-not (Get-Command Get-VMMManagedComputer -ea SilentlyContinue)) { Import-Module VirtualMachineManager -Force -ea SilentlyContinue }        If (-not (Get-Command Get-VMMManagedComputer -ea SilentlyContinue)) { Throw "ERROR: Unable to load VirutalMachineManger Powershell module" }        If (!$VMMServer) { $VMMServer = Read-Host "`nPlease supply the VMM server name" }        If (-not(Test-Connection $VMMServer -Quiet)) { Throw "ERROR: Unable to ping to $VMMServer" }        $CpsPrefix = $VMMServer.SubString(0, $VMMServer.IndexOf('-'))        If (-not(Get-SCVMMServer -ComputerName $VMMServer -ea SilentlyContinue)) { Throw "ERROR: Unable to connect to $VMMServer" }        $VMMVersion = (Get-VMMServer -ComputerName $VMMServer).ProductVersion        If ($NodeTypes -contains "MSU")        {            Get-SCVMHost -VMHostGroup "Management Cluster" | % { $MSUNodes += $_.FullyQualifiedDomainName }        }        If ($NodeTypes -contains "CSU")        {            Get-SCVMHost -VMHostGroup "Compute Clusters" | % { $CSUNodes += $_.FullyQualifiedDomainName }        }        If ($NodeTypes -contains "ESU")        {            Get-SCVMHost -VMHostGroup "Edge Clusters" | % { $ESUNodes += $_.FullyQualifiedDomainName }        }        If ($NodeTypes -contains "SSU")        {            Get-Cluster -Name (Get-SCStorageProvider).Name | Get-ClusterNode | % { $SSUNodes += $_.Name }        }        If ($NodeTypes -contains "VM")        {            Get-VMMManagedComputer | Where { $_.RoleString -ne "Host" } | % {                If ((Get-WmiObject Win32_BaseBoard -ComputerName $_.Name -ea SilentlyContinue).Product -eq "Virtual Machine") { $VMList += $_.Name }            }        }    }    Else    {        If (($NodeTypes -contains "MSU") -and ($RackNumber -eq 1))        {            If (!$MSUCluster)            {                If ($CpsPrefix)                {                    $MSUCluster = $CpsPrefix + "R1MC"                }                Else                {                    $MSUCluster = Read-Host "REQUIRED: Please supply the MSU Cluster"                 }            }            If (Get-Cluster $MSUCluster -ea SilentlyContinue)            {                Get-ClusterNode -Cluster $MSUCluster | % { $MSUNodes += $_.Name }            }            Else            {                Throw "ERROR: Could not find cluster named $MSUCluster"            }        }        If ($NodeTypes -contains "CSU")        {            If (!$CSUCluster)            {                If ($CpsPrefix)                {                    $CSUCluster = $CpsPrefix + "R" + $RackNumber + "CC"                }                Else                {                    $CSUCluster = Read-Host "REQUIRED: Please supply the CSU Cluster"                }            }            If (Get-Cluster $CSUCluster -ea SilentlyContinue)            {                Get-ClusterNode -Cluster $CSUCluster | % { $CSUNodes += $_.Name }            }            Else            {                Throw "ERROR: Could not find cluster named $CSUCluster"            }        }        If ($NodeTypes -contains "ESU")        {            If (!$ESUCluster)            {                If ($CpsPrefix)                {                    $ESUCluster = $CpsPrefix + "R" + $RackNumber + "EC"                }                Else                {                    $ESUCluster = Read-Host "REQUIRED: Please supply the ESU Cluster"                }            }            If (Get-Cluster $ESUCluster -ea SilentlyContinue)            {                Get-ClusterNode -Cluster $ESUCluster | % { $ESUNodes += $_.Name }            }            Else            {                Throw "ERROR: Could not find cluster named $ESUCluster"            }        }        If ($NodeTypes -contains "SSU")        {            If (!$SSUCluster)            {                If ($CpsPrefix)                {                    $SSUCluster = $CpsPrefix + "R" + $RackNumber + "SC"                }                Else                {                    $SSUCluster = Read-Host "REQUIRED: Please supply the SSU Cluster"                }            }            If (Get-Cluster $SSUCluster -ea SilentlyContinue)            {                Get-ClusterNode -Cluster $SSUCluster | % { $SSUNodes += $_.Name }            }            Else            {                Throw "ERROR: Could not find cluster named $SSUCluster"            }        }        If ($NodeTypes -contains "VM")        {            # $VMList += (Get-ADDomain).ReplicaDirectoryServers            # NOTE: Get-VM returns the VM Name but not the actual ComputerName of the VM            # Get-ClusterNode -Cluster $MSUCluster | % { $VMList += (Get-VM -ComputerName $_.Name).Name }            # NOTE: Get-ClusterResource has the same problem and needs more clean-up of the output            #(Get-ClusterResource -Cluster $MSUCluster | ? ResourceType -eq "Virtual Machine" | Select Name) | % { $VMList += $_.Name.Replace("SCVMM ","").Replace("Virtual Machine ","").Replace(" ","") }            $R1 = '<INSTANCE CLASSNAME="Msvm_KvpExchangeDataItem"><PROPERTY NAME="Caption" TYPE="string"></PROPERTY><PROPERTY NAME="Data" TYPE="string"><VALUE>'            $R2 = '</VALUE></PROPERTY><PROPERTY NAME="Description" TYPE="string"></PROPERTY><PROPERTY NAME="ElementName" TYPE="string"></PROPERTY><PROPERTY NAME="InstanceID" TYPE="string"></PROPERTY><PROPERTY NAME="Name" TYPE="string"><VALUE>FullyQualifiedDomainName</VALUE></PROPERTY><PROPERTY NAME="Source" TYPE="uint16"><VALUE>2</VALUE></PROPERTY></INSTANCE>'            If ($RackNumber -eq 1)            {                If (!$MSUCluster)                {                    If ($CpsPrefix)                    {                        $MSUCluster = $CpsPrefix + "R1MC"                    }                    Else                    {                        $MSUCluster = Read-Host "REQUIRED: Please supply the MSU Cluster"                     }                }                If (Get-Cluster $MSUCluster -ea SilentlyContinue)                {                    ForEach ($VMHost In (Get-ClusterNode -Cluster $MSUCluster))                    {                        Hyper-V\Get-VM -ComputerName $VMHost.Name | % {                            $VMName = "'" + $_.Name + "'"                            $VM = $Null                            $KVP = $Null                            $VMXML = $Null                            $VM = Get-WmiObject -ComputerName $($VMHost.Name) -Namespace 'root\virtualization\v2' -Query "Select * From Msvm_ComputerSystem Where ElementName=$VMName"                            If ($VM) { $KVP = Get-WmiObject -ComputerName $($VMHost.Name) -Namespace 'root\virtualization\v2' -Query "Associators of {$VM} Where AssocClass=Msvm_SystemDevice ResultClass=Msvm_KvpExchangeComponent" }                            If ($KVP) { $VMXML = $KVP.GuestIntrinsicExchangeItems | Select-String "FullyQualifiedDomainName" }                            If ($VMXML)                            {                                $FullName = $VMXML.Line.Replace($R1,"").Replace($R2,"")                                $VMList += $FullName                            }                            Else { $VMList += $_.Name }                        }                    }                }                Else                {                    Throw "ERROR: Could not find cluster named $MSUCluster"                }            }            If (!$ESUCluster)            {                If ($CpsPrefix)                {                    $ESUCluster = $CpsPrefix + "R1EC"                }                Else                {                    $ESUCluster = Read-Host "REQUIRED: Please supply the ESU Cluster"                 }            }            If (Get-Cluster $ESUCluster -ea SilentlyContinue)            {                ForEach ($VMHost In (Get-ClusterNode -Cluster $ESUCluster))                {                    Hyper-V\Get-VM -ComputerName $VMHost.Name | % {                        $VMName = "'" + $_.Name + "'"                        $VM = $Null                        $KVP = $Null                        $VMXML = $Null                        $VM = Get-WmiObject -ComputerName $($VMHost.Name) -Namespace 'root\virtualization\v2' -Query "Select * From Msvm_ComputerSystem Where ElementName=$VMName"                        If ($VM) { $KVP = Get-WmiObject -ComputerName $($VMHost.Name) -Namespace 'root\virtualization\v2' -Query "Associators of {$VM} Where AssocClass=Msvm_SystemDevice ResultClass=Msvm_KvpExchangeComponent" }                        If ($KVP) { $VMXML = $KVP.GuestIntrinsicExchangeItems | Select-String "FullyQualifiedDomainName" }                        If ($VMXML)                        {                            $FullName = $VMXML.Line.Replace($R1,"").Replace($R2,"")                            $VMList += $FullName                        }                        Else { $VMList += $_.Name }                    }                }            }            Else            {                Throw "ERROR: Could not find cluster named $ESUCluster"            }            If (!$CSUCluster)            {                If ($CpsPrefix)                {                    $CSUCluster = $CpsPrefix + "R1CC"                }                Else                {                    $CSUCluster = Read-Host "REQUIRED: Please supply the CSU Cluster"                 }            }            If (Get-Cluster $CSUCluster -ea SilentlyContinue)            {                ForEach ($VMHost In (Get-ClusterNode -Cluster $CSUCluster))                {                    $CSUIncludeVM = @()                    $CSUIncludeVM += ($CpsPrefix + "KMY-*")                    $CSUIncludeVM += ($CpsPrefix + "KPY-*")                    $CSUIncludeVM += ($CpsPrefix + "KSQ-*")                    $CSUIncludeVM += ($CpsPrefix + "KTP-*")                    $CSUIncludeVM += ($CpsPrefix + "KTS-*")                    $CSUIncludeVM += "DPM-TenantVM-*"                    $HostVMs = Hyper-V\Get-VM -ComputerName $VMHost.Name                    ForEach ($CheckVM In $HostVMs)                    {                        $VMName = "'" + $CheckVM.Name + "'"                        $VM = $Null                        $KVP = $Null                        $VMXML = $Null                        $VM = Get-WmiObject -ComputerName $($VMHost.Name) -Namespace 'root\virtualization\v2' -Query "Select * From Msvm_ComputerSystem Where ElementName=$VMName"                        If ($VM) { $KVP = Get-WmiObject -ComputerName $($VMHost.Name) -Namespace 'root\virtualization\v2' -Query "Associators of {$VM} Where AssocClass=Msvm_SystemDevice ResultClass=Msvm_KvpExchangeComponent" }                        If ($KVP) { $VMXML = $KVP.GuestIntrinsicExchangeItems | Select-String "FullyQualifiedDomainName" }                        If ($VMXML)                        {                            $FullName = $VMXML.Line.Replace($R1,"").Replace($R2,"")                            $CSUIncludeVM | ForEach-Object { If (($FullName.Split(".")[0]) -like $PSITem) { $VMList += $FullName } }                        }                        Else                        {                            $CSUIncludeVM | ForEach-Object { If (($CheckVM.Name.Split(".")[0]) -like $PSITem) { $VMList += $CheckVM.Name } }                        }                    }                }            }            Else            {                Throw "ERROR: Could not find cluster named $ESUCluster"            }        }    }}If (!$VMMVersion -and !$NoVMM){    If (-not (Get-Command Get-VMMManagedComputer -ea SilentlyContinue)) { Import-Module VirtualMachineManager -Force -ea SilentlyContinue }    If (-not(Get-SCVMMServer -ComputerName $VMMServer -ea SilentlyContinue)) { Throw "ERROR: Unable to connect to $VMMServer" }    $VMMVersion = (Get-VMMServer -ComputerName $VMMServer).ProductVersion}If (!$CpsPrefix) { $CpsPrefix = Read-Host "`nPlease supply the CPS Prefix string" }$DomainFQDN = (Get-ADDomain).DNSRootIf ($DomainFQDN -and $CpsPrefix -and !$SkipDPMAgent){    $DPMServer = ($CpsPrefix + "-DPM-01." + $DomainFQDN)    $DPMAgents = @{}    $DPMAgents = Invoke-Command $DPMServer `    {        $Agents=@{}        (Get-ProductionServer -DPMServerName $Args[0] -wa SilentlyContinue -ea SilentlyContinue | Where { $_.InstalledAgents.Count -gt 0 }) | % { $Agents.Add($_.ServerName, [string]$_.GetInstalledAgentVersion()) }        $Agents    } -ArgumentList $DPMServer    $DPMList = Get-ADComputer -Filter { Name -like "DPM-TenantVM*" }    ForEach ($DPMVM In $DPMList)    {        If (Test-Connection -ComputerName ($DPMVM.DNSHostName) -Quiet)        {            $DPMTenant = Invoke-Command ($DPMVM.DNSHostName) {                $Agents=@{}                (Get-ProductionServer -DPMServerName $Args[0] -wa SilentlyContinue -ea SilentlyContinue | Where { $_.InstalledAgents.Count -gt 0 }) | % { $Agents.Add($_.ServerName, [string]$_.GetInstalledAgentVersion()) }                $Agents            } -ArgumentList ($DPMVM.DNSHostName)            $DPMTenant.Keys | % { If ($DPMAgents.Keys -notcontains $_) { $DPMAgents.Add($_, $DPMTenant.$_) } }        }    }}
$xmlTemplate = @'<?xml version="1.0" encoding="utf-8"?><Rack Name="" Date="" Time="" VMMVersion=""><NodeType Name="" Count=""><Nodes><Node Name="" Build="" Model="" AbleToPing="" WSMan="" VMMServerVersion="" VMMAgentVersion="" DPMServerVersion="" DPMAgentVersion=""><Patches><Patch Name="" Date="" Version=""/></Patches><MsiPatches><MsiPatch Name="" State="" Date=""/></MsiPatches><Drivers><Driver Description="" Version="" DeviceId=""/></Drivers><Products><Product Name="" Version="" IdentifyingNumber=""/></Products><Updates><Update Title="" Date=""/></Updates><Firmware><Device Name="" Version="" Healthy=""/></Firmware></Node></Nodes></NodeType></Rack>'@$xmlTemplate | Out-File $xmlFile -Encoding UTF8
$xml = New-Object XML$xml.Load($xmlFile)$xml.Rack.Name = $RackName$xml.Rack.Date = $xmlDate$xml.Rack.Time = $xmlTimeIf ($VMMVersion) { $xml.Rack.VMMVersion = $VMMVersion }
$NewNodeType = (@($xml.Rack.NodeType)[0]).Clone()$NewNode = (@($xml.Rack.NodeType.Nodes.Node)[0]).Clone()$NewPatch = (@($xml.Rack.NodeType.Nodes.Node.Patches.Patch)[0]).Clone()$NewDriver = (@($xml.Rack.NodeType.Nodes.Node.Drivers.Driver)[0]).Clone()$NewUpdate = (@($xml.Rack.NodeType.Nodes.Node.Updates.Update)[0]).Clone()$NewFirmware = (@($xml.Rack.NodeType.Nodes.Node.Firmware.Device)[0]).Clone()$NewProduct = (@($xml.Rack.NodeType.Nodes.Node.Products.Product)[0]).Clone()$NewMsiPatch = (@($xml.Rack.NodeType.Nodes.Node.MsiPatches.MsiPatch)[0]).Clone()
[bool]$JbodDiskDone = $false
$UpdatesBlock ={    $Session = New-Object -ComObject "Microsoft.Update.Session"    $Searcher = $Session.CreateUpdateSearcher()    $historyCount = $Searcher.GetTotalHistoryCount()    If ($historyCount)    {        $Searcher.QueryHistory(0, $historyCount) | Select-Object Title, Date, @{Name="Operation"; Expression={Switch($_.Operation){1 {"Installation"}; 2 {"Uninstallation"}; 3 {"Other"}}}}    }}
If ($MSUNodes.Count -gt 0) { Write-Host ("INFO: MSU Count = " + $MSUNodes.Count) -ForegroundColor Cyan }If ($CSUNodes.Count -gt 0) { Write-Host ("INFO: CSU Count = " + $CSUNodes.Count) -ForegroundColor Cyan }If ($ESUNodes.Count -gt 0) { Write-Host ("INFO: ESU Count = " + $ESUNodes.Count) -ForegroundColor Cyan }If ($SSUNodes.Count -gt 0) { Write-Host ("INFO: SSU Count = " + $SSUNodes.Count) -ForegroundColor Cyan }If ($VMList.Count -gt 0) { Write-Host ("INFO:  VM Count = " + $VMList.Count) -ForegroundColor Cyan }
If ($SkipNodes.Count -gt 0){    $SkipNodes = $SkipNodes.ToUpper()    Write-Host "`n`nWILL BE SKIPPED IF FOUND...`n" -ForegroundColor Yellow    ForEach ($Node In $SkipNodes)    {        Write-Host $Node -ForegroundColor Cyan    }}
Write-Host "`n`nCOLLECTING INVENTORY...`n" -ForegroundColor Yellow
ForEach ($Type In $NodeTypes){    [int]$NodeCount = 0    $NodeTypeXML = $NewNodeType.Clone()    $NodeTypeXML.Name = $Type    If ($Type -eq "MANUAL") { $NodeList = $Nodes | Sort }    If ($Type -eq "MSU") { $NodeList = $MSUNodes | Sort }    If ($Type -eq "CSU") { $NodeList = $CSUNodes | Sort }    If ($Type -eq "ESU") { $NodeList = $ESUNodes | Sort }    If ($Type -eq "SSU") { $NodeList = $SSUNodes | Sort }    If ($Type -eq "VM") { $NodeList = $VMList | Sort }    If ($NodeList.Count -gt 0)    {          Write-Host "`nNODE TYPE: " -NoNewLine -ForegroundColor Cyan        Write-Host $Type -ForegroundColor White    }    ForEach ($Node In $NodeList)    {        [bool]$IsIPv4 = $false        [bool]$Skip = $false        [bool]$IsVM = $false        [bool]$SupportFiles = $false        If (Validate-IPv4 $Node) { $IsIPv4 = $true }        If ($SkipNodes.Count -gt 0)        {            If ($IsIPv4)            {                If ($SkipNodes.Contains($Node)) { $Skip = $true }            }            Else            {                If ($SkipNodes.Contains($Node)) { $Skip = $true }                If ($SkipNodes.Contains($Node.ToUpper())) { $Skip = $true }                If ($SkipNodes.Contains($Node.Split(".")[0].ToUpper())) { $Skip = $true }            }            If ($Skip)            {                Write-Host "   SKIP: " -NoNewLine -ForegroundColor DarkCyan                If ($IsIPv4) { Write-Host $Node -ForegroundColor Gray }                Else { Write-Host $Node.Split(".")[0].ToUpper() -ForegroundColor Gray }                Continue            }        }        $NodeCount++        $NodeXML = $NewNode.Clone()        $NodeXML.Name = $Node.Split(".")[0].ToUpper()        Write-Host "   NODE: " -NoNewLine -ForegroundColor DarkCyan        If ($IsIPv4)        {            Write-Host $Node -ForegroundColor Gray        }        Else        {            Write-Host $Node.Split(".")[0].ToUpper() -ForegroundColor Gray        }        If (Test-Connection -ComputerName $Node -Quiet)        {            $NodeXML.AbleToPing = "True"            If (Invoke-Command -ComputerName $Node -ScriptBlock { "TEST" } -ea SilentlyContinue)            {                If ((Get-WmiObject Win32_BaseBoard -ComputerName $Node -ea SilentlyContinue).Product -eq "Virtual Machine") { $IsVM = $true }                $NodeXML.WSMan = "True"                $SysDrv = Invoke-Command -ComputerName $Node { ($Env:SystemDrive).Replace(":","$") }                # Copy support files for firmware version checking locally if needed                If (Test-Path $SupportFilePath -ea SilentlyContinue)                {                    Robocopy $SupportFilePath "\\$Node\$SysDrv\TEMP" *.* /s /e /v | Out-Null                    If (Test-Path "\\$Node\$SysDrv\TEMP\_FWINFO_.txt" -ea SilentlyContinue)                    {                        $SupportFiles = $true                    }                    Else                    {                        Write-Host "         ERROR: Unable to copy files to \\$Node\$SysDrv\TEMP\" -ForegroundColor Red                    }                }                # Try and determine the server model                [string]$Model = [string](Get-WmiObject -Class Win32_ComputerSystem -ComputerName $Node -ea SilentlyContinue).Model                If ($Model)                {                    If ((Get-WmiObject -Class Win32_ComputerSystem -ComputerName $Node -ea SilentlyContinue).Model -match "C6220") { $Model = "DELL_C6220" }                    If ((Get-WmiObject -Class Win32_ComputerSystem -ComputerName $Node -ea SilentlyContinue).Model -match "C6220II") { $Model = "DELL_C6220II" }                    If ((Get-WmiObject -Class Win32_ComputerSystem -ComputerName $Node -ea SilentlyContinue).Model -match "R620") { $Model = "DELL_R620" }                    If ((Get-WmiObject -Class Win32_ComputerSystem -ComputerName $Node -ea SilentlyContinue).Model -match "R630") { $Model = "DELL_R630" }                    If ((Get-WmiObject -Class Win32_ComputerSystem -ComputerName $Node -ea SilentlyContinue).Model -match "S810-X52L") { $Model = "QUANTA_S810" }                    $NodeXML.Model = $Model                }                Else                {                    $NodeXML.Model = "Unknown"                }                [string]$Build = ""                $Build = Invoke-Command -Computer $Node { [System.Diagnostics.FileVersionInfo]::GetVersionInfo("$Env:WinDir\System32\cryptui.dll").FileVersion }                #$NodeXML.Build = [string](Invoke-Command -ComputerName $Node { (Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion").BuildLabEx })                $NodeXML.Build = $Build                # Get VMM server version                If ($Node -match "VMM")                {                    [string]$VMMSrvVer = (Get-VMMServer -ComputerName $VMMServer).ProductVersion                    If ($VMMSrvVer)                    {                        $NodeXML.VMMServerVersion = $VMMSrvVer                    }                }                # Get DPM server version                If ($Node -match "DPM")                {                    If ($Node.Split(".").Count -eq 1)                    {                        If ($DomainFQDN) { $DPMServer = ($Node + "." + $DomainFQDN) }                    }                    Else                    {                         $DPMServer = $Node                    }                    [string]$DPMSrvVer = Invoke-Command $DPMServer { (Connect-DPMServer -DPMServerName $Args[0] -wa SilentlyContinue -ea SilentlyContinue).GetProductInformation().Version } -ArgumentList $DPMServer                    If ($DPMSrvVer)                    {                        $NodeXML.DPMServerVersion = $DPMSrvVer                    }                }                # Get DPM agent version                If ($Node.Split(".").Count -gt 1)                {                    $DPMAgentKey = $Node.Split(".")[0]                }                Else                {                    $DPMAgentKey = $Node                }                If ($DPMAgents.Keys -contains $DPMAgentKey)                {                    $DPMAgentVersion = $DPMAgents.$DPMAgentKey                }                If ($DPMAgentVersion)                {                    $NodeXML.DPMAgentVersion = $DPMAgentVersion                }                # Get VMM agent version                If ($VMMServer -and !$NoVMM)                {                    $VMMAgentVersion = [string](Get-SCVMMManagedComputer -ComputerName $Node).AgentVersion                    If ($VMMAgentVersion)                    {                        $NodeXML.VMMAgentVersion = $VMMAgentVersion                    }                }                # Get Patches                [string[]]$DismPatch = Invoke-Command -Computer $Node { dism /online /get-packages }                Get-WmiObject -ComputerName $Node -Class Win32_QuickFixEngineering -ea SilentlyContinue | % {                    $Name = [string]$_.HotFixID                    $InstallDate = [string]$_.InstalledOn                    ForEach ($Line In $DismPatch)                    {                        If ($Line -match $Name)                        {                            $Version = $Line.Split('~',[StringSplitOptions]'RemoveEmptyEntries')[3]                        }                    }                    $PatchXML = $NewPatch.Clone()                    $PatchXML.Name = $Name                    $PatchXML.Version = $Version                    $PatchXML.Date = $InstallDate                    $NodeXML.Patches.AppendChild($PatchXML) | Out-Null                }                # Get Products                 Get-WmiObject -ComputerName $Node -Class Win32_Product -ea SilentlyContinue | % {                    $ProductXML = $NewProduct.Clone()                    $ProductXML.Name = [string]$_.Name                    $ProductXML.Version = [string]$_.Version                    $ProductXML.IdentifyingNumber = [string]$_.IdentifyingNumber                    $NodeXML.Products.AppendChild($ProductXML) | Out-Null                }                # Get Updates                Invoke-Command -ComputerName $Node -ScriptBlock $UpdatesBlock | % {                    $UpdateXML = $NewUpdate.Clone()                    $UpdateXML.Title = [string]$_.Title                    $UpdateXML.Date = [string]$_.Date                    $NodeXML.Updates.AppendChild($UpdateXML) | Out-Null                }                # Get MsiPatches                Invoke-Command -ComputerName $Node -ScriptBlock {                    Import-Module MSI -ea SilentlyContinue                    If ((Get-Module MSI -ea SilentlyContinue).Count -eq 0)                    {                        If (Test-Path "$Env:SystemDrive\TEMP\psmsi.msi")                        {                            $Log = "$Env:SystemDrive\TEMP\PSMSI_Install.log"                            Start-Process -WorkingDirectory "$Env:SystemDrive\TEMP" -FilePath msiexec.exe -ArgumentList "/i psmsi.msi /quiet" -Wait -RedirectStandardOutput $Log                        }                    }                }                $MsiPatches = Invoke-Command -ComputerName $Node -ScriptBlock {                    Import-Module MSI -ea SilentlyContinue                    If ((Get-Module MSI -ea SilentlyContinue).Count -ne 0)                    {                        Get-MSIPatchInfo                    }                }                If ($MsiPatches)                {                    ForEach ($Patch In $MsiPatches)                    {                        $MsiPatchXML = $NewMsiPatch.Clone()                        $MsiPatchXML.Name = [string]$Patch.DisplayName                        $MsiPatchXML.State = [string]$Patch.State                        $MsiPatchXML.Date = [string]$Patch.InstallDate                        $NodeXML.MsiPatches.AppendChild($MsiPatchXML) | Out-Null                    }                }                # Get Drivers                Get-WmiObject Win32_PNPSignedDriver -ComputerName $Node -ea SilentlyContinue | ? Manufacturer -like "Chelsio*" | % {                    $DriverXML = $NewDriver.Clone()                     $DriverXML.Description = [string]$_.Description                    $DriverXML.Version = [string]$_.DriverVersion                    $DriverXML.DeviceID = [string]$_.DeviceID                    $NodeXML.Drivers.AppendChild($DriverXML) | Out-Null                }                Get-WmiObject Win32_PNPSignedDriver -ComputerName $Node -ea SilentlyContinue | ? Manufacturer -like "LSI*" | % {                    $DriverXML = $NewDriver.Clone()                     $DriverXML.Description = [string]$_.Description                    $DriverXML.Version = [string]$_.DriverVersion                    $DriverXML.DeviceID = [string]$_.DeviceID                    $NodeXML.Drivers.AppendChild($DriverXML) | Out-Null                }                Get-WmiObject Win32_PNPSignedDriver -ComputerName $Node -ea SilentlyContinue | ? Description -match "Ethernet*" | % {                    $DriverXML = $NewDriver.Clone()                     $DriverXML.Description = [string]$_.Description                    $DriverXML.Version = [string]$_.DriverVersion                    $DriverXML.DeviceID = [string]$_.DeviceID                    $NodeXML.Drivers.AppendChild($DriverXML) | Out-Null                }                Get-WmiObject Win32_PNPSignedDriver -ComputerName $Node -ea SilentlyContinue | ? Manufacturer -like "Mellanox*" | % {                    $DriverXML = $NewDriver.Clone()                     $DriverXML.Description = [string]$_.Description                    $DriverXML.Version = [string]$_.DriverVersion                    $DriverXML.DeviceID = [string]$_.DeviceID                    $NodeXML.Drivers.AppendChild($DriverXML) | Out-Null                }                Get-WmiObject Win32_PNPSignedDriver -ComputerName $Node -ea SilentlyContinue | ? DeviceName -match " SATA " | % {                    $DriverXML = $NewDriver.Clone()                     $DriverXML.Description = [string]$_.Description                    $DriverXML.Version = [string]$_.DriverVersion                    $DriverXML.DeviceID = [string]$_.DeviceID                    $NodeXML.Drivers.AppendChild($DriverXML) | Out-Null                }                # Get Firmware                $SysModel = (Get-WmiObject -Class Win32_ComputerSystem -ComputerName $Node -ea SilentlyContinue).Model                $SysBIOS = Get-WmiObject -Class Win32_BIOS -ComputerName $Node -ea SilentlyContinue                If ($SysBIOS)                {                    $FirmwareXML = $NewFirmware.Clone()                    If (($SysModel -match "R630") -or ($SysModel -match "C6320"))                    {                        $FirmwareXML.Name = [string]("SYSBIOS:" + $SysModel + " " + $SysBIOS.Name)                    }                    Else                    {                        $FirmwareXML.Name = [string]"SYSBIOS:" + $SysBIOS.Name                    }                    $FirmwareXML.Version = [string]$SysBIOS.SMBIOSBIOSVersion                    $NodeXML.Firmware.AppendChild($FirmwareXML) | Out-Null                }                # Skip the rest of the firmware versions for VMs                If(!$IsVM)                {                    # Get internal disk versions                    $LocalDisks = Invoke-Command -ComputerName $Node -ScriptBlock { Get-PhysicalDisk | ? PhysicalLocation -eq $null }                    ForEach ($Disk In $LocalDisks)                    {                        If ($Disk.Size -ge 1TB) { $Size = ([string]($Disk.Size/1TB)).Split('.')[0] + "TB" }                        Else { $Size = ([string]($Disk.Size/1GB)).Split('.')[0] + "GB" }                        [string]$Id = $null                        [string]$Mfg = $null                        [string]$Mdl = $null                        [string]$Type = $null                        [string]$Healthy = $null                        If ($Disk.DeviceId -ne $null) { [string]$Id = [string]$Disk.DeviceId }                        If ($Disk.Manufacturer -ne $null) { $Mfg = [string]($Disk.Manufacturer).Trim() }                        If ($Disk.Model -ne $null) { $Mdl = [string]($Disk.Model).Trim() }                        If (($Disk.MediaType -eq "3") -or ($Disk.MediaType -match "HDD")) { $Type = "HDD" }                        ElseIf (($Disk.MediaType -eq "4") -or ($Disk.MediaType -match "SSD")) { $Type = "SSD" }                        If ($Disk.HealthStatus -ne $null)                        {                            If (($Disk.HealthStatus -eq "0") -or ($Disk.HealthStatus -eq "Healthy")) { $Healthy = "True" }                            Else { $Healthy = "False" }                        }                        If ($Disk.OperationalStatus -ne $null)                        {                            If (($Disk.OperationalStatus -eq "2") -or ($Disk.OperationalStatus -eq "OK")) { $Healthy = "True" }                            Else                            {                                $Healthy = "False"                                If (!$Mdl) { $Mdl = [string]$Disk.OperationalStatus }                            }                        }                        $FirmwareXML = $NewFirmware.Clone()                        $FirmwareXML.Name = ("LOCAL_DISK-$Id" + ": $Mfg $Mdl $Size $Type")                        $FirmwareXML.Version = [string]$Disk.FirmwareVersion                        $FirmwareXML.Healthy = $Healthy                        $NodeXML.Firmware.AppendChild($FirmwareXML) | Out-Null                    }                    # Will need the SupportFiles to get firmware information - also there is no need to get Firmware info for VMs                    If (($SupportFiles) -and ($Type -ne "VM"))                    {                        # Get the Chelsio versions                        $chelsio = Invoke-Command -ComputerName $Node -ScriptBlock { & $Env:SystemDrive\TEMP\chelsio_uwlite.exe chelsio listadapters }                        If ($chelsio)                        {                            ForEach ($line in $chelsio)                            {                                If ($line -match "Bios Version")                                {                                    $chelsio_bootver = $line.Split(":",[StringSplitOptions]'RemoveEmptyEntries')[1].Replace(" ","")                                }                                If ($line -match "Model")                                {                                    $chelsio_model = ($line.Split(":",[StringSplitOptions]'RemoveEmptyEntries')[1]).Replace(" ","")                                }                                [string]$chelsio_name = "CHELSIO BOOT OPT ROM"                                If ($chelsio_model) { [string]$chelsio_name = "CHELSIO " + $chelsio_model + " BOOT OPT ROM" }                            }                            If ($chelsio_bootver)                            {                                $FirmwareXML = $NewFirmware.Clone()                                $FirmwareXML.Name = ($chelsio_name)                                $FirmwareXML.Version = [string]$chelsio_bootver                                $NodeXML.Firmware.AppendChild($FirmwareXML) | Out-Null                            }                        }                        # Get the Mellanox versions                        $mellanox = Invoke-Command -ComputerName $Node -ScriptBlock {                            $Output = & $Env:SystemDrive\TEMP\mst.exe status                            If ($Output)                            {                                If (!($Output -match "No MST devices found"))                                {                                    $Device = ($Output | Select-String "_pci_").ToString().Replace(" ","")                                    & $Env:SystemDrive\TEMP\flint.exe -d $Device -qq q                                }                            }                        }                        If ($mellanox)                        {                            $mellanox_ver = ($mellanox | Select-String "FW Version").ToString().Split(":",[StringSplitOptions]'RemoveEmptyEntries')[1].Replace(" ","")                            $mellanox_name = "MELLANOX: mt"                            $mellanox_name += ($mellanox | Select-String "Device ID").ToString().Split(":",[StringSplitOptions]'RemoveEmptyEntries')[1].Replace(" ","")                            $FirmwareXML = $NewFirmware.Clone()                            $FirmwareXML.Name = ($mellanox_name)                            $FirmwareXML.Version = [string]$mellanox_ver                            $NodeXML.Firmware.AppendChild($FirmwareXML) | Out-Null                        }                        # Get the LSI SAS Controller version                        $lsisas = Invoke-Command -ComputerName $Node -ScriptBlock { & $Env:SystemDrive\TEMP\sas2flash.exe -listall }                        If ($lsisas)                        {                            ForEach ($line in $lsisas)                            {                                $ctrl = $line.Split(" ",[StringSplitOptions]'RemoveEmptyEntries')                                If (($ctrl[1] -match "SAS") -and (-not ($ctrl[1] -match "SAS2Flash")))                                {                                    $FirmwareXML = $NewFirmware.Clone()                                    $FirmwareXML.Name = ("LSI " + $ctrl[1])                                    $FirmwareXML.Version = [string]$ctrl[2]                                    $NodeXML.Firmware.AppendChild($FirmwareXML) | Out-Null                                }                            }                        }                        If ($Model -match "C6220")                        {                            # Get the BMC version                            $bmc = Invoke-Command -ComputerName $Node { & $Env:SystemDrive\TEMP\ipmiutil.exe cmd 00 20 18 01 }                            If ($bmc)                            {                                [string]$line = $bmc | Select-String "BMC Version"                                If ($line)                                {                                    $bmcver = $line.Split(",")[0].Replace("-- BMC version ","")                                    $FirmwareXML = $NewFirmware.Clone()                                    $FirmwareXML.Name = "BMC"                                    $FirmwareXML.Version = $bmcver                                    $NodeXML.Firmware.AppendChild($FirmwareXML) | Out-Null                                }                            }                        }                        If (($Type -eq "SSU") -or ($Model -match "R620") -or ($Model -match "R630"))                        {                            If (($Model -match "R620") -or ($Model -match "R630"))                            {                                # Get the ESM/iDRAC version                                $log = "ESM_CHECK.txt"                                If (Test-Path "\\$Node\$SysDrv\TEMP\$log" -ea SilentlyContinue) { Remove-Item "\\$Node\$SysDrv\TEMP\$log" -Force }                                Invoke-Command -ComputerName $Node -ScriptBlock { Param($log) Start-Process -FilePath "$Env:SystemDrive\TEMP\DELL_ESM_1.56.55.exe" -ArgumentList "/c /s /l=$Env:SystemDrive\TEMP\$log" -Wait } -ArgumentList $log                                Start-Sleep -seconds 3                                $idrac = Get-Content "\\$Node\$SysDrv\TEMP\$log" -ea SilentlyContinue                                If ($idrac)                                {                                    If ($idrac -match "Exit code = 3")                                    {                                        [string]$version = ($idrac | Select-String  "Installed version:")[0]                                        If ($version)                                        {                                            $version = [string]$version.Split(":",[StringSplitOptions]'RemoveEmptyEntries')[1].Replace(" ","")                                            $FirmwareXML = $NewFirmware.Clone()                                            $FirmwareXML.Name = "ESM: Dell iDRAC7"                                            $FirmwareXML.Version = $version                                            $NodeXML.Firmware.AppendChild($FirmwareXML) | Out-Null                                        }                                    }                                }                                # Get the Lifecycle Controller version                                $log = "LC_CHECK.txt"                                If (Test-Path "\\$Node\$SysDrv\TEMP\$log" -ea SilentlyContinue) { Remove-Item "\\$Node\$SysDrv\TEMP\$log" -Force }                                Invoke-Command -ComputerName $Node -ScriptBlock { Param($log) Start-Process -FilePath "$Env:SystemDrive\TEMP\DELL_LC_1.4.0.128.exe" -ArgumentList "/c /s /l=$Env:SystemDrive\TEMP\$log" -Wait } -ArgumentList $log                                Start-Sleep -seconds 3                                $lc = Get-Content "\\$Node\$SysDrv\TEMP\$log" -ea SilentlyContinue                                If ($lc)                                {                                    If ($lc -match "Exit code = 3")                                    {                                        [string]$version = ($lc | Select-String  "Installed version:")[0]                                        If ($version)                                        {                                            $version = [string]$version.Split(":",[StringSplitOptions]'RemoveEmptyEntries')[1].Replace(" ","")                                            $FirmwareXML = $NewFirmware.Clone()                                            $FirmwareXML.Name = "Dell Lifecycle Controller"                                            $FirmwareXML.Version = $version                                            $NodeXML.Firmware.AppendChild($FirmwareXML) | Out-Null                                       }                                    }                                }                                If (!$SkipDisks)                                {                                    # Get JBOD enclosure firmware version                                    $StorageEnclosures = Invoke-Command -ComputerName $Node -ScriptBlock { Get-StorageEnclosure }                                    If ($StorageEnclosures -and (!$UseSECLI))                                    {                                        ForEach ($Enclosure In $StorageEnclosures)                                        {                                            [string]$Mfg = $null                                            [string]$Mdl = $null                                            [string]$Name = $null                                            [string]$Healthy = $null                                            If ($Enclosure.Manufacturer -ne $null) { $Mfg = [string]($Enclosure.Manufacturer).Trim() }                                            If ($Enclosure.Model -ne $null) { $Mdl = [string]($Enclosure.Model).Trim() }                                            If ($Enclosure.UniqueId -ne $null) { $Name = [string]($Enclosure.UniqueId).Trim() }                                            If ($Enclosure.HealthStatus -ne $null)                                            {                                                If (($Enclosure.HealthStatus -eq "Healthy") -or ($Enclosure.HealthStatus -eq "0")) { $Healthy = "True" }                                                Else { $Healthy = "False" }                                            }                                            $FirmwareXML = $NewFirmware.Clone()                                            $FirmwareXML.Name = "EMM: $Mfg $Mdl - $Name"                                            $FirmwareXML.Version = [string]$Enclosure.FirmwareVersion                                            $FirmwareXML.Healthy = $Healthy                                            $NodeXML.Firmware.AppendChild($FirmwareXML) | Out-Null                                        }                                    }                                    Else                                    {                                        # Use the SECLI tool instead of Powershell cmdlets (Dell only)                                        $emms = Invoke-Command -ComputerName $Node -ScriptBlock { & $Env:SystemDrive\TEMP\SECLI.exe list emms -a=0 }                                        $emms += Invoke-Command -ComputerName $Node -ScriptBlock { & $Env:SystemDrive\TEMP\SECLI.exe list emms -a=1 }                                        If ($emms.Count -gt 0)                                        {                                            ForEach ($line In $emms)                                            {                                                If ($line.Contains("MD3060e"))                                                {                                                    $item = $line.Split(" ",[StringSplitOptions]'RemoveEmptyEntries')                                                    If ($item[4] -eq "OK") { $Healthy = "True" }                                                    Else { $Healthy = "False" }                                                    $FirmwareXML = $NewFirmware.Clone()                                                    $FirmwareXML.Name = [string]("EMM: Dell MD3060e WWN:" + $item[1])                                                    $FirmwareXML.Version = [string]$item[5]                                                    $FirmwareXML.Healthy = $Healthy                                                    $NodeXML.Firmware.AppendChild($FirmwareXML) | Out-Null                                                }                                            }                                        }                                    }                                    If (!$JbodDiskDone)                                    {                                        # Get JBOD disk drive firmware versions - only done on one SSU node per rack to save time                                        $Disks = $null                                        If (!$UseSECLI)                                        {                                            $Disks = Invoke-Command -ComputerName $Node -ScriptBlock `                                            {                                                Get-StorageEnclosure | Get-PhysicalDisk | Select DeviceId,MediaType,Manufacturer,Model,FirmwareVersion,Size,HealthStatus,OperationalStatus,SerialNumber | Sort DeviceId                                            }                                        }                                        If ($Disks)                                        {                                            $JbodDiskDone = $true                                            ForEach ($Disk In $Disks)                                            {                                                [string]$Mfg = $null                                                [string]$Mdl = $null                                                [string]$SN = $null                                                [string]$Healthy = $null                                                If ($Disk.Size -ge 1TB) { $Size = ([string]($Disk.Size/1TB)).Split('.')[0] + "TB" }                                                Else { $Size = ([string]($Disk.Size/1GB)).Split('.')[0] + "GB" }                                                If ($Disk.Manufacturer -ne $null) { $Mfg = [string]($Disk.Manufacturer).Trim() }                                                If ($Disk.Model -ne $null) { $Mdl = [string]($Disk.Model).Trim() }                                                If ($Disk.SerialNumber -ne $null) { $SN = [string]($Disk.SerialNumber).Trim() }                                                If (($Disk.OperationalStatus -ne "OK") -or ($Disk.HealthStatus -ne "Healthy")) { $Healthy = "False" }                                                ElseIf (($Disk.OperationalStatus -eq "OK") -and ($Disk.HealthStatus -eq "Healthy")) { $Healthy = "True" }                                                $FirmwareXML = $NewFirmware.Clone()                                                $FirmwareXML.Name = [string]("DISK-" + $Disk.DeviceId + ": " + $Mfg + " " + $Mdl + " " + $SN + " " + $Size + " " + $Disk.MediaType)                                                $FirmwareXML.Version = [string]$Disk.FirmwareVersion                                                $FirmwareXML.Healthy = $Healthy                                                $NodeXML.Firmware.AppendChild($FirmwareXML) | Out-Null                                            }                                        }                                        Else                                        {                                            # Use the SECLI tool (Dell only)                                            $drives = Invoke-Command -ComputerName $Node -ScriptBlock { & $Env:SystemDrive\TEMP\SECLI.exe list drives -a=0 }                                            # Still use Get-PhysicalDisk for health and other information that SECLI does not supply                                            $Disks = Invoke-Command -ComputerName $Node -ScriptBlock { Get-PhysicalDisk | Select DeviceId,MediaType,Manufacturer,Model,FirmwareVersion,Size,HealthStatus,OperationalStatus,SerialNumber }                                            If ($drives.Count -gt 0)                                            {                                                ForEach ($line In $drives)                                                {                                                    $item = $line.Split(" ",[StringSplitOptions]'RemoveEmptyEntries')                                                    If ($item[1] -like "*PHYSICALDRIVE*")                                                    {                                                        $JbodDiskDone = $true                                                        $Healthy = $null                                                        $Id = $DiskSN                                                        $DiskType = $null                                                        $Disk = $null                                                        $DiskSN = $null                                                        $DiskMfg = $null                                                        $DiskModel = $null                                                        $DiskSize = $null                                                        $DiskVer = $null                                                        $FirmwareXML = $NewFirmware.Clone()                                                        $DiskSN = [string]$item[4]                                                        If (!$DiskSN) { $DiskSN = [string]$item[0] }                                                        $DiskMfg = [string]$item[2]                                                        $DiskModel = [string]$item[3]                                                        $DiskSize = [string]$item[6]                                                        $DiskVer = [string]$item[5]                                                        $Disk = $Disks | Where-Object SerialNumber -eq $DiskSN                                                        If ($Disk)                                                        {                                                            If (($Disk.OperationalStatus -ne "OK") -or ($Disk.HealthStatus -ne "Healthy")) { $Healthy = "False" }                                                            ElseIf (($Disk.OperationalStatus -eq "OK") -and ($Disk.HealthStatus -eq "Healthy")) { $Healthy = "True" }                                                            [string]$DiskType = $Disk.MediaType                                                            [string]$Id = $Disk.DeviceId                                                        }                                                        $FirmwareXML.Name = [string]("DISK-" + $Id + ": " + $DiskMfg + " " + $DiskModel + " " + $DiskSize + " " + $DiskType)                                                        $FirmwareXML.Version = $DiskVer                                                        $FirmwareXML.Healthy = $Healthy                                                        $NodeXML.Firmware.AppendChild($FirmwareXML) | Out-Null                                                    }                                                }                                            }                                        }                                    }                                }                            }                            Else                            {                                # Server is a non-Dell R620 or R630 so cannot use the SECLI tool                                If (!$SkipDisks)                                {                                    # Get JBOD enclosure firmware version                                    $StorageEnclosures = Invoke-Command -ComputerName $Node -ScriptBlock { Get-StorageEnclosure }                                    If ($StorageEnclosures)                                    {                                        ForEach ($Enclosure In $StorageEnclosures)                                        {                                            [string]$Mfg = $null                                            [string]$Mdl = $null                                            [string]$Name = $null                                            [string]$Healthy = $null                                            If ($Enclosure.Manufacturer) { $Mfg = [string]($Enclosure.Manufacturer).Trim() }                                            If ($Enclosure.Model) { $Mdl = [string]($Enclosure.Model).Trim() }                                            If ($Enclosure.UniqueId) { $Name = [string]($Enclosure.UniqueId).Trim() }                                            If ($Enclosure.HealthStatus)                                            {                                                If ($Enclosure.HealthStatus -eq "Healthy") { $Healthy = "True" }                                                Else { $Healthy = "False" }                                            }                                            $FirmwareXML = $NewFirmware.Clone()                                            $FirmwareXML.Name = "EMM: $Mfg $Mdl - $Name"                                            $FirmwareXML.Version = [string]$Enclosure.FirmwareVersion                                            $FirmwareXML.Healthy = $Healthy                                            $NodeXML.Firmware.AppendChild($FirmwareXML) | Out-Null                                        }                                    }                                   # Get disk firmware versions                                    $Disks = Invoke-Command -ComputerName $Node -ScriptBlock { Get-StorageEnclosure | Get-PhysicalDisk | Select DeviceId, MediaType, Manufacturer, Model, FirmwareVersion, Size, SerialNumber }                                    If ($Disks)                                    {                                        $JbodDiskDone = $true                                        ForEach ($Disk In $Disks)                                        {                                            [string]$Mfg = $null                                            [string]$Mdl = $null                                            [string]$SN = $null                                            [string]$Healthy = $null                                            If ($Disk.Size -ge 1TB) { $Size = ([string]($Disk.Size/1TB)).Split('.')[0] + "TB" }                                            Else { $Size = ([string]($Disk.Size/1GB)).Split('.')[0] + "GB" }                                            If ($Disk.Manufacturer) { $Mfg = [string]($Disk.Manufacturer).Trim() }                                            If ($Disk.Model) { $Mdl = [string]($Disk.Model).Trim() }                                            If ($Disk.SerialNumber -ne $null) { $SN = [string]($Disk.SerialNumber).Trim() }                                            If (($Disk.OperationalStatus -ne "OK") -or ($Disk.HealthStatus -ne "Healthy")) { $Healthy = "False" }                                            ElseIf (($Disk.OperationalStatus -eq "OK") -and ($Disk.HealthStatus -eq "Healthy")) { $Healthy = "True" }                                            $FirmwareXML = $NewFirmware.Clone()                                            $FirmwareXML.Name = [string]("DISK-" + $Disk.DeviceId + ": " + $Mfg + " " + $Mdl + " " + $SN + " " + $Size + " " + $Disk.MediaType)                                            $FirmwareXML.Version = [string]$Disk.FirmwareVersion                                            $FirmwareXML.Healthy = $Healthy                                            $NodeXML.Firmware.AppendChild($FirmwareXML) | Out-Null                                        }                                    }                                }                            }                        }                    }                }            }            Else            {                Write-Host "         ERROR: Failed to connect via WSMan" -ForegroundColor Red                $NodeXML.WSMan = "False"            }        }        Else        {            Write-Host "         ERROR: Unable to connect" -ForegroundColor Red            $NodeXML.AbleToPing = "False"            $NodeXML.WSMan = "False"        }        # Append the Node        $NodeTypeXML.Nodes.AppendChild($NodeXML) | Out-Null    }    # Append the NodeType    $NodeTypeXML.Count = $NodeCount.ToString()    $xml.Rack.AppendChild($NodeTypeXML) | Out-Null}# Clean up items with Null namesFunction Clean-XML{    ForEach ($Type In $xml.Rack.NodeType)    {        If ($Type.Name -eq "")        {            [void]$xml.Rack.RemoveChild($Type)        }        Else        {            ForEach ($Node In $Type.Nodes.Node)            {                If ($Node.Name -eq "")                {                    [void]$Node.ParentNode.RemoveChild($Node)                }                Else                {                    ForEach ($Patch In $Node.Patches.Patch)                    {                        If ($Patch.Name -eq "")                        {                            [void]$Patch.ParentNode.RemoveChild($Patch)                        }                    }                    ForEach ($Update In $Node.Updates.Update)                    {                        If ($Update.Title -eq "")                        {                            [void]$Update.ParentNode.RemoveChild($Update)                        }                    }                    ForEach ($Driver In $Node.Drivers.Driver)                    {                        If ($Driver.Description -eq "")                        {                            [void]$Driver.ParentNode.RemoveChild($Driver)                        }                    }                    ForEach ($Product In $Node.Products.Product)                    {                        If ($Product.IdentifyingNumber -eq "")                        {                            [void]$Product.ParentNode.RemoveChild($Product)                        }                    }                    ForEach ($MsiPatch In $Node.MsiPatches.MsiPatch)                    {                        If ($MsiPatch.Name -eq "")                        {                            [void]$MsiPatch.ParentNode.RemoveChild($MsiPatch)                        }                    }                    ForEach ($Firmware In $Node.Firmware.Device)                    {                        If ($Firmware.Name -eq "")                        {                            [void]$Firmware.ParentNode.RemoveChild($Firmware)                        }                    }                }            }        }    }}$EndTime = Get-DateWrite-Host "`n`nTIME ELAPSED : " -NoNewLine -ForegroundColor YellowWrite-Host ([string]($EndTime - $StartTime).Hours + "H:" + [string]($EndTime - $StartTime).Minutes + "M:" + [string]($EndTime - $StartTime).Seconds + "S") -ForegroundColor WhiteClean-XML$xml.Save($xmlFile)[xml]$xml = Get-Content $xmlFileClean-XML$xml.Save($xmlFile)Write-Host "`n`nFILE SAVED TO : " -NoNewLine -ForegroundColor GreenWrite-Host "$xmlFile`n" -ForegroundColor White
